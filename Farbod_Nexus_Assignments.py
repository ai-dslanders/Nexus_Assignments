# -*- coding: utf-8 -*-
"""Copy of AI‚ÄìDS Nexus | A0.1. Python | RezaShokr.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SbdMhe29CxT3Bl-QbwU7JBqtzVaF7rZc

# üìö Assignment 1 ‚Äî Python Fundamentals
Welcome to your first hands-on practice! This set of four mini-projects walks you through the basics every Python (and ML) developer leans on daily:

1. Variable types

2. Core containers

3. Functions

4. Classes

Each part begins with quick pointers, then gives you two bite-sized tasks to code. Replace every # TODO with working Python and run your script or notebook to check the result. Happy hacking! üòä

## 1. Variable Types üßÆ
**Quick-start notes**

* Primitive types: `int`, `float`, `str`, `bool`

* Use `type(obj)` to inspect an object‚Äôs type.

* Casting ‚Üî converting: `int("3")`, `str(3.14)`, `bool(0)`, etc.

### Task 1 ‚Äî Celsius ‚Üí Fahrenheit
"""

# üëâ a Celsius temperature (as text), convert it to float,
#    compute Fahrenheit (¬∞F = ¬∞C * 9/5 + 32) and print a nicely formatted line.
# TODO: your code here

celsius=float("29.5")
print(celsius)
fahrenheit=celsius*9/5 + 32
print(fahrenheit)
print(f"{celsius}¬∞C is {fahrenheit}¬∞F")

"""### Task 2 ‚Äî Tiny Calculator

"""

# üëâ Store two numbers of **different types** (one int, one float),
#    then print their sum, difference, product, true division, and floor division.
# TODO: your code here

num1=5
num2=3.14
sum_result= num1 + num2
diff_result = num1 - num2
prod_result = num1 * num2
true_div_result = num1 / num2
floor_div_result = num1 // num2
print(f'Sum : {sum_result}')
print(f'Difference : {diff_result}')
print(f'Product : {prod_result}')
print(f'True Division : {true_div_result}')
print(f'Floor Division : {floor_div_result}')

"""## 2. Containers üì¶ (list, tuple, set, dict)
**Quick-start notes**

| Container | Mutable? | Ordered?                      | Typical use                       |
| --------- | -------- | ----------------------------- | --------------------------------- |
| `list`    | ‚úî        | ‚úî                             | Growth, indexing, slicing         |
| `tuple`   | ‚úñ        | ‚úî                             | Fixed-size records, hashable keys |
| `set`     | ‚úî        | ‚úñ                             | Deduplication, membership tests   |
| `dict`    | ‚úî        | ‚úñ (3.7 + preserves insertion) | Key ‚Üí value look-ups              |

### Task 1 ‚Äî Grocery Basket
"""

# Start with an empty shopping list (list).
# 1. Append at least 4 items supplied in one line of user input (comma-separated).
# 2. Convert the list to a *tuple* called immutable_basket.
# 3. Print the third item using tuple indexing.
# TODO: your code here

shopping_list = []
items = "milk,cheese,egg,jam"
shopping_list = [item.strip() for item in items.split(',') if item.strip()]

immutable_basket = tuple(shopping_list)
print(shopping_list)
print("Third item:", immutable_basket[2])

"""### Task 2 ‚Äî Word Stats"""

sample = "to be or not to be that is the question"

# 1. Build a set `unique_words` containing every distinct word.
# 2. Build a dict `word_counts` mapping each word to the number of times it appears.
#    (Hint: .split() + a simple loop)
# 3. Print the two structures and explain (in a comment) their main difference.
# TODO: your code here

text="to be or not to be that is the question"
words=text.split()
unique_words=set(words)

word_counts={}
for w in words:
  word_counts[w] = word_counts.get(w,0) + 1
print("Unique.words", unique_words)
print("Word.Counts", word_counts)
# ÿ™Ÿàÿ∂€åÿ≠ ÿ™ŸÅÿßŸàÿ™ ÿßÿµŸÑ€å:
# ‚Äì unique_words €å⁄© set ÿßÿ≥ÿ™ ⁄©Ÿá ŸÅŸÇÿ∑ ⁄©ŸÑŸÖÿßÿ™ ŸÖÿ™ŸÖÿß€åÿ≤ (€å⁄©‚Äåÿ®ÿßÿ±) ÿ±ÿß ŸÜ⁄ØŸá ŸÖ€å‚ÄåÿØÿßÿ±ÿØ .
# ‚Äì word_counts €å⁄© dict ÿßÿ≥ÿ™ ⁄©Ÿá Ÿáÿ± ⁄©ŸÑŸÖŸá ÿ±ÿß ÿ®Ÿá ÿ™ÿπÿØÿßÿØ ÿØŸÅÿπÿßÿ™€å ⁄©Ÿá ÿØÿ± ŸÖÿ™ŸÜ ÿ¢ŸÖÿØŸáÿå ŸÜ⁄Øÿßÿ¥ÿ™ ŸÖ€å‚Äå⁄©ŸÜÿØ.

"""## 3. Functions üîß
**Quick-start notes**

* Define with `def`, return with `return`.

* Parameters can have default values.

* Docstrings (`''' ‚Ä¶ '''`) document behaviour.

### Task 1 ‚Äî Prime Tester
"""

def is_prime(n: int) -> bool:
    """
    Return True if n is a prime number, else False.
    0 and 1 are *not* prime.
    """
    # TODO: replace pass with your implementation
    if n<2 :
      return False

    for i in range(2,n):
       if n % i ==0:
          return False

    return True



# Quick self-check
print([x for x in range(10) if is_prime(x)])   # Expected: [2, 3, 5, 7]

"""### Task 2 ‚Äî Repeater Greeter"""

def greet(name: str, times: int = 1) -> None:
    """Print `name`, capitalised, exactly `times` times on one line."""
    # TODO: your code here
def greet(name: str, times: int = 1) -> None:
  cap_name = name.capitalize()
  print(" ".join([cap_name] * times))
greet("farbod", 4)
greet("alice")          # Alice
greet("bob", times=3)   # Bob Bob Bob

"""## 4. Classes üèóÔ∏è
**Quick-start notes**

* Create with class Name:

* Special method __init__ runs on construction.

* self refers to the instance; attributes live on self.

### Task 1 ‚Äî Simple Counter
"""

class Counter:
    """Counts how many times `increment` is called."""
    # TODO:
    # 1. In __init__, store an internal count variable starting at 0.
    # 2. Method increment(step: int = 1) adds `step` to the count.
    # 3. Method value() returns the current count.

class Counter:
    def __init__(self):
        self.count = 0

    def increment(self, step: int = 1):
        self.count += step

    def value(self):
        return self.count

a = Counter()
a.increment()
a.increment(3)
print(a.value())

"""### Task 2 ‚Äî 2-D Point with Distance"""

import math

class Point:
    """
    A 2-D point supporting distance calculation.
    Usage:
        p = Point(3, 4)
        q = Point(0, 0)
        print(p.distance_to(q))  # 5.0
    """
    # TODO:
    # 1. Store x and y as attributes.
    # 2. Implement distance_to(other) using the Euclidean formula.

import math

class Point:

  def __init__(self, x, y):
        self.x = x
        self.y = y
  def distance_to(self, other):
        dx = self.x - other.x
        dy = self.y - other.y
        return math.sqrt(dx ** 2 + dy ** 2)

p = Point(5, 12)
q = Point(0, 0)
print(p.distance_to(q))

# Smoke test
p, q = Point(3, 4), Point(0, 0)
assert round(p.distance_to(q), 1) == 5.0